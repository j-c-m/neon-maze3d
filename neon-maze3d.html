<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Neon Maze - v4.0</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            touch-action: none;
        }
        canvas {
            width: 100%;
            height: 100vh;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 16px;
            z-index: 20;
        }
        #achievementElement, #restartButton, #menu {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 20;
            touch-action: none;
        }
        #achievementElement {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
        }
        #restartButton {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            display: none;
        }
        #menu {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            flex-direction: column;
            gap: 10px;
        }
        .menu-button {
            padding: 8px 16px;
            cursor: pointer;
            user-select: none;
        }
        .menu-button:hover {
            background: rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body>
    <div id="ui">Score: 0 | Time: 0s</div>
    <div id="achievementElement">Congratulations! You reached the finish!<br>Tap or press Space to restart.</div>
    <div id="restartButton">Tap to Restart</div>
    <div id="menu"></div>
    <script type="importmap">
        {
          "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@v0.173.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@v0.173.0/examples/jsm/"
          }
        }
    </script>
    <script type="module">
        /*
         * Changelog:
         * Version 4.0  - Updated to major version 4.0 with no functional changes
         * Version 3.59 - Added configurable loops and increased dead-end paths in maze generation for higher difficulty
         * Version 3.58 - Rotated player to face an open direction (not a wall) at start, corrected yaw alignment
         * Version 3.57 - Refined touch controls: swipe up and hold to move forward, swipe left/right to rotate
         * Version 3.56 - Factored difficulty into a config block; maxSpeed and pathSpeed constant at 0.8; dynamic menu
         * Version 3.55 - Adjusted mazes: Easy (25x25) ~1min, Medium (75x75) ~3min, Hard (350x350) ~15min
         * Version 3.54 - Adjusted maze size by difficulty: Easy (50x50), Medium (75x75), Hard (100x100)
         * Version 3.53 - Ensured distinct wall/floor colors, added neon palette
         * Version 3.52 - Switched to iterative stack-based backtracking
         * Version 3.51 - Replaced Kruskalâ€™s with Recursive Backtracking
         *
         * Instructions for Future Changes:
         * 1. Increment the version number (e.g., 3.59 -> 3.60) in the <title> and changelog.
         * 2. Add a new entry to this changelog with the version and a brief description of changes.
         * 3. Include the last 10 most recent changes in the changelog.
         * 4. Generate a Git commit command and include it below the changelog.
         * 5. Do not remove these instructions in future updates.
         * 6. Do not remove comments that document variables and code logic.
         *
         * Git Commit Command for this change:
         * git commit -m "Moved and documented config constants into a config object, no version increment" neon-maze3d.html
         */

        import * as THREE from 'three';
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const difficulties = {
            easy: {
                mazeWidth: 25,
                mazeHeight: 25,
                fogDistance: 8,
                directionBias: 0.7,
                loopProbability: 0.05,  // Low chance of loops
                deadEndProbability: 0.1 // Few dead ends
            },
            medium: {
                mazeWidth: 75,
                mazeHeight: 75,
                fogDistance: 6,
                directionBias: 0.6,
                loopProbability: 0.15,  // Moderate loops
                deadEndProbability: 0.3 // More dead ends
            },
            hard: {
                mazeWidth: 350,
                mazeHeight: 350,
                fogDistance: 5,
                directionBias: 0.4,
                loopProbability: 0.25,  // High chance of loops
                deadEndProbability: 0.5 // Many dead ends
            }
        };

        // Game configuration constants
        const config = {
            visibilityRadius: 15,      // Distance in cells for rendering walls around the player
            cellSize: 2,              // Size of each maze cell in world units
            wallThickness: 0.01,      // Thickness of walls, floor, and ceiling in world units
            maxSpeed: 0.8,            // Maximum speed of manual player movement
            pathSpeed: 0.8,           // Speed of automated path-following movement
            safeDistance: 0.01 + 0.25, // Minimum distance from walls to prevent clipping (wallThickness + buffer)
            friction: 0.15,           // Rate at which velocity decays when no input is given
            rotationSpeed: 0.002,     // Speed of camera rotation with mouse movement
            rotationLerpSpeed: 0.1    // Speed of camera rotation interpolation during path-following
        };

        let currentDifficulty = difficulties.easy;
        let mazeWidth, mazeHeight;
        let maze = [], walls = new Map(), floor, ceiling, startMarker, finishMarker;
        let gameActive = false, startTime, score = 0;
        let start = { x: 0, z: 0 }, finish;
        let path = null, pathIndex = 0, pathMarkers = [];
        let fogActive = true;
        let fogColor = 0x111111;

        let pointLight;
        let wallMaterials = {};

        function generateMaze() {
            mazeWidth = currentDifficulty.mazeWidth;
            mazeHeight = currentDifficulty.mazeHeight;
            const loopProbability = currentDifficulty.loopProbability;
            const deadEndProbability = currentDifficulty.deadEndProbability;

            maze = [];
            for (let x = 0; x < mazeWidth; x++) {
                maze[x] = [];
                for (let z = 0; z < mazeHeight; z++) {
                    maze[x][z] = 0;
                }
            }

            let vWalls = Array(mazeWidth + 1).fill().map(() => Array(mazeHeight).fill(true));
            let hWalls = Array(mazeWidth).fill().map(() => Array(mazeHeight + 1).fill(true));

            const directions = [
                { dx: 1, dz: 0, wall: 'v', wx: 1, wz: 0 },
                { dx: -1, dz: 0, wall: 'v', wx: 0, wz: 0 },
                { dx: 0, dz: 1, wall: 'h', wx: 0, wz: 1 },
                { dx: 0, dz: -1, wall: 'h', wx: 0, wz: 0 }
            ];

            function shuffleDirections(arr, bias) {
                if (bias < 0.5) {
                    arr.sort(() => Math.random() - bias);
                } else {
                    arr.sort((a, b) => (a.dx + a.dz) - (b.dx + b.dz));
                    if (Math.random() > bias) arr.reverse();
                }
                return arr;
            }

            const stack = [{ x: 0, z: 0 }];
            const visited = new Set();
            visited.add("0,0");
            maze[0][0] = 1;

            while (stack.length > 0) {
                const current = stack[stack.length - 1];
                const { x, z } = current;

                const neighbors = [];
                const shuffledDirections = shuffleDirections([...directions], currentDifficulty.directionBias);

                for (const dir of shuffledDirections) {
                    const nx = x + dir.dx;
                    const nz = z + dir.dz;
                    if (nx >= 0 && nx < mazeWidth && nz >= 0 && nz < mazeHeight && !visited.has(`${nx},${nz}`)) {
                        neighbors.push(dir);
                    }
                }

                if (neighbors.length > 0) {
                    const dir = neighbors[Math.floor(Math.random() * neighbors.length)];
                    const nx = x + dir.dx;
                    const nz = z + dir.dz;
                    const wx = x + dir.wx;
                    const wz = z + dir.wz;

                    if (dir.wall === 'v') vWalls[wx][wz] = false;
                    else if (dir.wall === 'h') hWalls[wx][wz] = false;

                    maze[nx][nz] = 1;
                    visited.add(`${nx},${nz}`);
                    stack.push({ x: nx, z: nz });

                    // Add dead-end paths with probability
                    if (Math.random() < deadEndProbability && neighbors.length > 1) {
                        const extraDir = neighbors[Math.floor(Math.random() * (neighbors.length - 1))];
                        if (extraDir !== dir) {
                            const ex = x + extraDir.dx;
                            const ez = z + extraDir.dz;
                            const ewx = x + extraDir.wx;
                            const ewz = z + extraDir.wz;
                            if (ex >= 0 && ex < mazeWidth && ez >= 0 && ez < mazeHeight && !visited.has(`${ex},${ez}`)) {
                                if (extraDir.wall === 'v') vWalls[ewx][ewz] = false;
                                else if (extraDir.wall === 'h') hWalls[ewx][ewz] = false;
                                maze[ex][ez] = 1;
                                visited.add(`${ex},${ez}`);
                            }
                        }
                    }
                } else {
                    stack.pop();
                }
            }

            // Add loops by removing additional walls
            for (let x = 0; x < mazeWidth; x++) {
                for (let z = 0; z < mazeHeight; z++) {
                    if (Math.random() < loopProbability) {
                        if (x < mazeWidth - 1 && Math.random() < 0.5) {
                            vWalls[x + 1][z] = false; // Remove vertical wall
                        }
                        if (z < mazeHeight - 1 && Math.random() < 0.5) {
                            hWalls[x][z + 1] = false; // Remove horizontal wall
                        }
                    }
                }
            }

            maze.vWalls = vWalls;
            maze.hWalls = hWalls;
            finish = { x: mazeWidth - 1, z: mazeHeight - 1 };
        }

        function renderMaze() {
            const neonColors = [
                0xff00ff, 0x00ffff, 0xffff00, 0xff00aa, 0x00ffaa,
                0xff5500, 0x5500ff, 0xff0055, 0x00ff00, 0x0055ff
            ];
            const wallColor = neonColors[Math.floor(Math.random() * neonColors.length)];
            const availableFloorColors = neonColors.filter(color => color !== wallColor);
            const floorCeilingColor = availableFloorColors[Math.floor(Math.random() * availableFloorColors.length)];

            wallMaterials.wall = new THREE.MeshPhongMaterial({
                color: wallColor,
                emissive: wallColor,
                emissiveIntensity: 0.5,
                shininess: 100,
                opacity: 1.0,
                transparent: false,
                side: THREE.DoubleSide,
                shininess: 30
            });
            wallMaterials.floorCeiling = new THREE.MeshPhongMaterial({
                color: floorCeilingColor,
                emissive: floorCeilingColor,
                emissiveIntensity: 0.5,
                shininess: 100,
                opacity: 1.0,
                transparent: false,
                side: THREE.DoubleSide,
                shininess: 10
            });

            walls.clear();

            const floorGeometry = new THREE.BoxGeometry(mazeWidth * config.cellSize, config.wallThickness, mazeHeight * config.cellSize);
            floor = new THREE.Mesh(floorGeometry, wallMaterials.floorCeiling);
            floor.position.set(0, -config.cellSize / 2 + config.wallThickness / 2, 0);
            scene.add(floor);

            const ceilingGeometry = new THREE.BoxGeometry(mazeWidth * config.cellSize, config.wallThickness, mazeHeight * config.cellSize);
            ceiling = new THREE.Mesh(ceilingGeometry, wallMaterials.floorCeiling);
            ceiling.position.set(0, config.cellSize / 2 - config.wallThickness / 2, 0);
            scene.add(ceiling);

            const startMarkerGeometry = new THREE.SphereGeometry(0.3);
            const startMarkerMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00, shininess: 150 });
            startMarker = new THREE.Mesh(startMarkerGeometry, startMarkerMaterial);
            const startX = start.x * config.cellSize - mazeWidth * config.cellSize / 2 + config.cellSize / 2;
            const startZ = start.z * config.cellSize - mazeHeight * config.cellSize / 2 + config.cellSize / 2;
            startMarker.position.set(startX, 0, startZ);
            scene.add(startMarker);

            const finishMarkerGeometry = new THREE.SphereGeometry(0.3);
            const finishMarkerMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000, shininess: 150 });
            finishMarker = new THREE.Mesh(finishMarkerGeometry, finishMarkerMaterial);
            const finishX = finish.x * config.cellSize - mazeWidth * config.cellSize / 2 + config.cellSize / 2;
            const finishZ = finish.z * config.cellSize - mazeHeight * config.cellSize / 2 + config.cellSize / 2;
            finishMarker.position.set(finishX, 0, finishZ);
            scene.add(finishMarker);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            pointLight = new THREE.PointLight(0xffffff, 50, 25);
            pointLight.position.set(startX, 2, startZ);
            scene.add(pointLight);

            scene.fog = null;
            updateFog(fogColor);

            camera.position.set(startX, 0.1, startZ);

            const directions = [
                { name: 'East', dx: 1, dz: 0, yaw: -Math.PI / 2 },
                { name: 'South', dx: 0, dz: 1, yaw: -Math.PI },
                { name: 'North', dx: 0, dz: -1, yaw: 0 },
                { name: 'West', dx: -1, dz: 0, yaw: Math.PI / 2 }
            ];

            let openDirectionFound = false;
            console.log("Checking directions from start (0, 0):");
            for (const dir of directions) {
                const nx = start.x + dir.dx;
                const nz = start.z + dir.dz;
                let isOpen = false;

                if (nx >= 0 && nx < mazeWidth && nz >= 0 && nz < mazeHeight) {
                    if (dir.dx === 1 && !maze.vWalls[1][0]) isOpen = true;
                    else if (dir.dx === -1 && !maze.vWalls[0][0]) isOpen = true;
                    else if (dir.dz === 1 && !maze.hWalls[0][1]) isOpen = true;
                    else if (dir.dz === -1 && !maze.hWalls[0][0]) isOpen = true;
                }

                console.log(`${dir.name}: Adjacent (${nx}, ${nz}), Open: ${isOpen}, vWalls[1][0]: ${maze.vWalls[1][0]}, hWalls[0][1]: ${maze.hWalls[0][1]}, vWalls[0][0]: ${maze.vWalls[0][0]}, hWalls[0][0]: ${maze.hWalls[0][0]}`);

                if (isOpen) {
                    camera.rotation.y = dir.yaw;
                    console.log(`Set to face ${dir.name} (yaw: ${dir.yaw})`);
                    openDirectionFound = true;
                    break;
                }
            }

            if (!openDirectionFound) {
                console.warn("No open direction found! Defaulting to East (yaw: -Ï€/2)");
                camera.rotation.y = -Math.PI / 2;
            }

            gameActive = true;
        }

        function updateVisibleObjects() {
            const playerX = Math.floor((camera.position.x + mazeWidth * config.cellSize / 2) / config.cellSize);
            const playerZ = Math.floor((camera.position.z + mazeHeight * config.cellSize / 2) / config.cellSize);

            const minX = Math.max(0, playerX - config.visibilityRadius);
            const maxX = Math.min(mazeWidth, playerX + config.visibilityRadius);
            const minZ = Math.max(0, playerZ - config.visibilityRadius);
            const maxZ = Math.min(mazeHeight, playerZ + config.visibilityRadius);

            const newWalls = new Set();

            for (let x = minX; x <= maxX; x++) {
                for (let z = minZ; z < maxZ; z++) {
                    if (maze.vWalls[x][z]) {
                        let startZ = z;
                        let length = 0;
                        while (startZ + length < mazeHeight && maze.vWalls[x][startZ + length] && startZ + length < maxZ) {
                            length++;
                        }
                        const key = `v_${x}_${startZ}_${length}`;
                        newWalls.add(key);
                        if (!walls.has(key)) {
                            const geometry = new THREE.BoxGeometry(config.wallThickness, config.cellSize, config.cellSize * length);
                            const wall = new THREE.Mesh(geometry, wallMaterials.wall);
                            const posX = x * config.cellSize - mazeWidth * config.cellSize / 2;
                            const posZ = (startZ + (length - 1) / 2) * config.cellSize - mazeHeight * config.cellSize / 2 + config.cellSize / 2;
                            wall.position.set(posX, 0, posZ);
                            scene.add(wall);
                            walls.set(key, { mesh: wall, x: x, z: startZ, length: length, isVertical: true });
                        }
                        z += length - 1;
                    }
                }
            }

            for (let z = minZ; z <= maxZ; z++) {
                for (let x = minX; x < maxX; x++) {
                    if (maze.hWalls[x][z]) {
                        let startX = x;
                        let length = 0;
                        while (startX + length < mazeWidth && maze.hWalls[startX + length][z] && startX + length < maxX) {
                            length++;
                        }
                        const key = `h_${startX}_${z}_${length}`;
                        newWalls.add(key);
                        if (!walls.has(key)) {
                            const geometry = new THREE.BoxGeometry(config.cellSize * length, config.cellSize, config.wallThickness);
                            const wall = new THREE.Mesh(geometry, wallMaterials.wall);
                            const posX = (startX + (length - 1) / 2) * config.cellSize - mazeWidth * config.cellSize / 2 + config.cellSize / 2;
                            const posZ = z * config.cellSize - mazeHeight * config.cellSize / 2;
                            wall.position.set(posX, 0, posZ);
                            scene.add(wall);
                            walls.set(key, { mesh: wall, x: startX, z: z, length: length, isVertical: false });
                        }
                        x += length - 1;
                    }
                }
            }

            for (let [key, wall] of walls) {
                if (!newWalls.has(key)) {
                    scene.remove(wall.mesh);
                    walls.delete(key);
                }
            }
        }

        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let velocity = new THREE.Vector3(0, 0, 0);
        const raycaster = new THREE.Raycaster();

        document.addEventListener('mousemove', (e) => {
            if (gameActive && !path) camera.rotation.y -= e.movementX * config.rotationSpeed;
        });
        document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock;
        document.addEventListener('click', () => {
            if (gameActive && !path) document.body.requestPointerLock();
        });

        let touchActive = false;
        let touchStartX = 0, touchStartY = 0;
        let lastTouchX = 0, lastTouchY = 0;

        document.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1 && gameActive && !path) {
                touchActive = true;
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                lastTouchX = touchStartX;
                lastTouchY = touchStartY;
                moveForward = false;
            }
        });

        document.addEventListener('touchmove', (e) => {
            if (touchActive && e.touches.length === 1 && gameActive && !path) {
                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY;
                const deltaX = touchX - lastTouchX;
                const deltaY = touchY - touchStartY;

                if (deltaY < -50) {
                    moveForward = true;
                }

                const rotationDelta = deltaX * 0.008;
                camera.rotation.y -= rotationDelta;

                lastTouchX = touchX;
                lastTouchY = touchY;
            }
        });

        document.addEventListener('touchend', () => {
            if (gameActive && !path) {
                touchActive = false;
                moveForward = false;
            }
        });

        document.addEventListener('keydown', (e) => {
            if (gameActive) {
                switch (e.key.toLowerCase()) {
                    case 'w': if (!path) moveForward = true; break;
                    case 's': if (!path) moveBackward = true; break;
                    case 'a': if (!path) moveLeft = true; break;
                    case 'd': if (!path) moveRight = true; break;
                    case 't':
                        if (path) {
                            path = null;
                            velocity.set(0, 0, 0);
                            renderPathMarkers();
                        } else {
                            const startX = Math.floor((camera.position.x + mazeWidth * config.cellSize / 2) / config.cellSize);
                            const startZ = Math.floor((camera.position.z + mazeHeight * config.cellSize / 2) / config.cellSize);
                            path = aStarPathfinding({ x: startX, z: startZ }, finish);
                            pathIndex = 0;
                            moveForward = moveBackward = moveLeft = moveRight = false;
                            velocity.set(0, 0, 0);
                            renderPathMarkers();
                        }
                        break;
                    case 'p':
                        document.body.classList.toggle('debug-path');
                        renderPathMarkers();
                        break;
                    case 'f':
                        fogActive = !fogActive;
                        updateFog(fogColor);
                        break;
                }
            } else if (e.key === ' ' && achievementElement.style.display === 'block') {
                restartGame();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (gameActive && !path) {
                switch (e.key.toLowerCase()) {
                    case 'w': moveForward = false; break;
                    case 's': moveBackward = false; break;
                    case 'a': moveLeft = false; break;
                    case 'd': moveRight = false; break;
                }
            }
        });

        const uiElement = document.getElementById('ui');
        const achievementElement = document.getElementById('achievementElement');
        const restartButton = document.getElementById('restartButton');
        const menu = document.getElementById('menu');

        function setupMenu() {
            menu.innerHTML = '';
            Object.keys(difficulties).forEach(difficultyKey => {
                const button = document.createElement('div');
                button.className = 'menu-button';
                button.textContent = difficultyKey.charAt(0).toUpperCase() + difficultyKey.slice(1);
                button.addEventListener('click', () => startGame(difficultyKey));
                button.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startGame(difficultyKey);
                });
                menu.appendChild(button);
            });
        }

        function showMenu() {
            menu.style.display = 'flex';
            gameActive = false;
        }

        function hideMenu() {
            menu.style.display = 'none';
        }

        [achievementElement, restartButton].forEach(element => {
            element.addEventListener('touchstart', (e) => { e.preventDefault(); handleTouchEvent(element); });
            element.addEventListener('click', (e) => { e.preventDefault(); handleTouchEvent(element); });
        });

        function handleTouchEvent(element) {
            if (element === achievementElement || element === restartButton) {
                if (!gameActive) restartGame();
            }
        }

        function startGame(difficultyKey) {
            currentDifficulty = difficulties[difficultyKey];
            console.log(`Starting game with difficulty: ${difficultyKey}...`);
            hideMenu();
            gameActive = true;
            startTime = performance.now();
            score = 0;
            path = null;
            velocity.set(0, 0, 0);
            moveForward = moveBackward = moveLeft = moveRight = false;
            updateUI();
            generateMaze();
            renderMaze();
            animate();
        }

        function showAchievement() {
            achievementElement.style.display = 'block';
            restartButton.style.display = 'block';
            gameActive = false;
            path = null;
            const timeTaken = Math.floor((performance.now() - startTime) / 1000);
            score = Math.max(0, 1000 - timeTaken * 10);
            updateUI();
        }

        function restartGame() {
            scene.clear();
            walls.clear();
            maze = [];
            start = { x: 0, z: 0 };
            gameActive = true;
            startTime = performance.now();
            path = null;
            velocity.set(0, 0, 0);
            moveForward = moveBackward = moveLeft = moveRight = false;
            pathMarkers.forEach(marker => scene.remove(marker));
            pathMarkers = [];
            showMenu();
            achievementElement.style.display = 'none';
            restartButton.style.display = 'none';
        }

        function updateFog(color) {
            if (fogActive) {
                scene.fog = new THREE.Fog(color, 1, currentDifficulty.fogDistance);
            } else {
                scene.fog = null;
            }
        }

        function updateUI() {
            if (gameActive) {
                const timeElapsed = Math.floor((performance.now() - startTime) / 1000);
                uiElement.textContent = `Score: ${score} | Time: ${timeElapsed}s`;
            }
        }

        function renderPathMarkers() {
            pathMarkers.forEach(marker => scene.remove(marker));
            pathMarkers = [];
            if (path && document.body.classList.contains('debug-path')) {
                path.forEach(node => {
                    const marker = new THREE.Mesh(
                        new THREE.SphereGeometry(0.05),
                        new THREE.MeshBasicMaterial({ color: 0x00ffff })
                    );
                    marker.position.set(
                        node.x * config.cellSize - mazeWidth * config.cellSize / 2 + config.cellSize / 2,
                        0,
                        node.z * config.cellSize - mazeHeight * config.cellSize / 2 + config.cellSize / 2
                    );
                    scene.add(marker);
                    pathMarkers.push(marker);
                });
            }
        }

        function aStarPathfinding(startPos, endPos) {
            const openSet = [startPos];
            const cameFrom = new Map();
            const gScore = new Map();
            const fScore = new Map();

            gScore.set(`${startPos.x},${startPos.z}`, 0);
            fScore.set(`${startPos.x},${startPos.z}`, heuristic(startPos, endPos));

            while (openSet.length > 0) {
                openSet.sort((a, b) => fScore.get(`${a.x},${a.z}`) - fScore.get(`${b.x},${b.z}`));
                const current = openSet.shift();

                if (current.x === endPos.x && current.z === endPos.z) {
                    return reconstructPath(cameFrom, current);
                }

                const neighbors = getNeighbors(current);
                for (const neighbor of neighbors) {
                    const tentativeGScore = gScore.get(`${current.x},${current.z}`) + 1;
                    const neighborKey = `${neighbor.x},${neighbor.z}`;

                    if (!gScore.has(neighborKey) || tentativeGScore < gScore.get(neighborKey)) {
                        cameFrom.set(neighborKey, current);
                        gScore.set(neighborKey, tentativeGScore);
                        fScore.set(neighborKey, tentativeGScore + heuristic(neighbor, endPos));
                        if (!openSet.some(n => n.x === neighbor.x && n.z === neighbor.z)) {
                            openSet.push(neighbor);
                        }
                    }
                }
            }
            return null;
        }

        function heuristic(a, b) {
            return Math.abs(a.x - b.x) + Math.abs(a.z - b.z);
        }

        function getNeighbors(pos) {
            const neighbors = [];
            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
            for (const [dx, dz] of directions) {
                const nx = pos.x + dx;
                const nz = pos.z + dz;
                if (nx >= 0 && nx < mazeWidth && nz >= 0 && nz < mazeHeight) {
                    if (dx === 1 && !maze.vWalls[pos.x + 1][pos.z]) neighbors.push({ x: nx, z: nz });
                    else if (dx === -1 && !maze.vWalls[pos.x][pos.z]) neighbors.push({ x: nx, z: nz });
                    else if (dz === 1 && !maze.hWalls[pos.x][pos.z + 1]) neighbors.push({ x: nx, z: nz });
                    else if (dz === -1 && !maze.hWalls[pos.x][pos.z]) neighbors.push({ x: nx, z: nz });
                }
            }
            return neighbors;
        }

        function reconstructPath(cameFrom, current) {
            const path = [current];
            while (cameFrom.has(`${current.x},${current.z}`)) {
                current = cameFrom.get(`${current.x},${current.z}`);
                path.unshift(current);
            }
            return path;
        }

        function animate() {
            if (!gameActive) return;

            requestAnimationFrame(animate);

            updateVisibleObjects();
            const wallMeshes = Array.from(walls.values()).map(w => w.mesh);

            const startDist = camera.position.distanceTo(startMarker.position);
            startMarker.visible = startDist <= config.visibilityRadius * config.cellSize;
            const finishDist = camera.position.distanceTo(finishMarker.position);
            finishMarker.visible = finishDist <= config.visibilityRadius * config.cellSize;

            const startX = camera.position.x;
            const startZ = camera.position.z;
            pointLight.position.set(startX, 2, startZ);

            if (path && pathIndex < path.length) {
                const targetGrid = path[pathIndex];
                const targetX = targetGrid.x * config.cellSize - mazeWidth * config.cellSize / 2 + config.cellSize / 2;
                const targetZ = targetGrid.z * config.cellSize - mazeHeight * config.cellSize / 2 + config.cellSize / 2;
                const direction = new THREE.Vector3(targetX - camera.position.x, 0, targetZ - camera.position.z).normalize();

                const targetQuaternion = new THREE.Quaternion().setFromUnitVectors(
                    new THREE.Vector3(0, 0, -1),
                    direction
                );
                camera.quaternion.slerp(targetQuaternion, config.rotationLerpSpeed);

                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                const moveStep = forward.multiplyScalar(config.pathSpeed * 0.05);
                let newPosition = camera.position.clone().add(moveStep);

                raycaster.set(camera.position, forward);
                const intersects = raycaster.intersectObjects(wallMeshes);

                if (intersects.length > 0 && intersects[0].distance <= moveStep.length() + config.safeDistance) {
                    const hitPoint = intersects[0].point;
                    const normal = intersects[0].face.normal.clone().applyQuaternion(intersects[0].object.quaternion);
                    newPosition = hitPoint.clone().sub(forward.clone().multiplyScalar(config.safeDistance));
                }

                camera.position.copy(newPosition);

                if (camera.position.distanceTo(new THREE.Vector3(targetX, camera.position.y, targetZ)) < 0.1) {
                    pathIndex++;
                }
            } else {
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                let moveDirection = new THREE.Vector3();

                if (moveForward) moveDirection.add(forward);
                if (moveBackward) moveDirection.add(forward.clone().negate());
                if (moveLeft) moveDirection.add(right.clone().negate());
                if (moveRight) moveDirection.add(right);

                if (moveDirection.length() > 0) {
                    moveDirection.normalize();
                    velocity.copy(moveDirection.multiplyScalar(config.maxSpeed));
                } else {
                    velocity.lerp(new THREE.Vector3(0, 0, 0), config.friction);
                }

                const moveStep = velocity.clone().multiplyScalar(0.1);
                let newPosition = camera.position.clone();

                if (moveStep.length() > 0) {
                    const checkDirections = [
                        forward,
                        forward.clone().negate(),
                        right,
                        right.clone().negate(),
                        forward.clone().add(right).normalize(),
                        forward.clone().sub(right).normalize(),
                        forward.clone().negate().add(right).normalize(),
                        forward.clone().negate().sub(right).normalize()
                    ];

                    let finalMove = moveStep.clone();

                    for (const dir of checkDirections) {
                        raycaster.set(camera.position, dir);
                        const intersects = raycaster.intersectObjects(wallMeshes);
                        if (intersects.length > 0 && intersects[0].distance <= moveStep.length() + config.safeDistance) {
                            const normal = intersects[0].face.normal.clone().applyQuaternion(intersects[0].object.quaternion);
                            const moveDotNormal = finalMove.dot(normal);
                            if (moveDotNormal < 0) {
                                finalMove.sub(normal.clone().multiplyScalar(moveDotNormal));
                            }
                        }
                    }

                    newPosition.add(finalMove);

                    const sweepDirections = [
                        new THREE.Vector3(1, 0, 0),
                        new THREE.Vector3(-1, 0, 0),
                        new THREE.Vector3(0, 0, 1),
                        new THREE.Vector3(0, 0, -1)
                    ];
                    for (const dir of sweepDirections) {
                        raycaster.set(newPosition, dir);
                        const intersects = raycaster.intersectObjects(wallMeshes);
                        if (intersects.length > 0 && intersects[0].distance < config.safeDistance) {
                            const normal = intersects[0].face.normal.clone().applyQuaternion(intersects[0].object.quaternion);
                            const correction = normal.clone().multiplyScalar(config.safeDistance - intersects[0].distance);
                            newPosition.add(correction);
                        }
                    }

                    newPosition.x = Math.max(-mazeWidth * config.cellSize / 2 + config.safeDistance, Math.min(mazeWidth * config.cellSize / 2 - config.safeDistance, newPosition.x));
                    newPosition.z = Math.max(-mazeHeight * config.cellSize / 2 + config.safeDistance, Math.min(mazeHeight * config.cellSize / 2 - config.safeDistance, newPosition.z));
                }

                camera.position.copy(newPosition);
                if (velocity.length() < 0.01 && !moveForward && !moveBackward && !moveLeft && !moveRight) {
                    velocity.set(0, 0, 0);
                }
            }

            const distanceToFinish = camera.position.distanceTo(finishMarker.position);
            if (distanceToFinish < 0.5) {
                showAchievement();
            } else if (distanceToFinish < 2) {
                finishMarker.scale.lerp(new THREE.Vector3(1.2, 1.2, 1.2), 0.1);
            } else {
                finishMarker.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
            }

            updateUI();
            renderer.render(scene, camera);
        }

        setupMenu();
        showMenu();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
