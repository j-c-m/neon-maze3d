<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Neon Maze - v3.49</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            touch-action: none;
        }
        canvas {
            width: 100%;
            height: 100vh;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 16px;
            z-index: 20;
        }
        #achievementElement, #restartButton, #menu {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 20;
            touch-action: none;
        }
        #achievementElement {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
        }
        #restartButton {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            display: none;
        }
        #menu {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            flex-direction: column;
            gap: 10px;
        }
        .menu-button {
            padding: 8px 16px;
            cursor: pointer;
            user-select: none;
        }
        .menu-button:hover {
            background: rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body>
    <div id="ui">Score: 0 | Time: 0s</div>
    <div id="achievementElement">Congratulations! You reached the finish!<br>Tap or press Space to restart.</div>
    <div id="restartButton">Tap to Restart</div>
    <div id="menu">
        <div class="menu-button" id="easyButton">Easy</div>
        <div class="menu-button" id="mediumButton">Medium</div>
        <div class="menu-button" id="hardButton">Hard</div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        /*
         * Changelog:
         * Previous versions omitted for brevity (see original code for full history up to v3.39)
         *
         * Version 3.42
         * - Fixed Hunt-and-Kill algorithm to ensure all cells are visited and start (0,0) is connected to finish (99,99)
         * - Added connectivity validation using flood-fill; falls back to recursive backtracking if maze is impossible
         * - Maintained high dead-end density for difficulty
         *
         * Version 3.43
         * - Replaced Hunt-and-Kill with Recursive Division algorithm for a more difficult maze with long corridors and dead ends
         * - Ensured solvability with single passages per division, kept start at (0,0) and finish at (99,99)
         * - Removed connectivity validation as Recursive Division guarantees a solvable maze
         *
         * Version 3.44
         * - Added difficulty levels (Easy, Medium, Hard) affecting maze complexity via minimum corridor length in Recursive Division
         * - Simplified menu to only show difficulty options; selecting a difficulty starts the game immediately
         * - Fixed infinite recursion in divide() by ensuring valid split conditions with difficulty
         *
         * Version 3.45
         * - Fixed Recursive Division to generate long corridors instead of big rooms by adjusting wall placement logic
         * - Difficulty now controls corridor length more effectively (Easy: shorter, Hard: longer)
         *
         * Version 3.46
         * - Replaced Recursive Division with Sidewinder algorithm to generate mazes with long horizontal corridors
         * - Difficulty controls average run length (Easy: ~5, Medium: ~10, Hard: ~20)
         *
         * Version 3.47
         * - Replaced Sidewinder with Binary Tree algorithm for balanced corridors without large rooms
         * - Difficulty controls randomness in passage direction (Easy: biased, Medium: moderate, Hard: random)
         *
         * Version 3.48
         * - Replaced Binary Tree with Kruskal’s algorithm for organic, winding corridors
         * - Difficulty controls connection probability (Easy: more connections, Medium: balanced, Hard: fewer connections)
         *
         * Version 3.49
         * - Removed unnecessary opening of start (0,0) and finish (99,99) walls in Kruskal’s, as player starts inside maze
         *
         * Instructions for Future Changes:
         * 1. Increment the version number (e.g., 3.49 -> 3.50) in the <title> and changelog.
         * 2. Add a new entry to this changelog with the version and a brief description of changes.
         * 3. Include the last 10 most recent changes in the changelog.
         * 4. Generate a Git commit command (e.g., git commit -m "Version X.Y: Description of changes") and include it below the changelog.
         * 5. Do not summarize previous code changes in brackets or any other method; always provide the full source code in its entirety.
         *
         * Useful Constants and Tips:
         * - maxSpeed (0.8): Controls manual movement speed; increase for faster movement, decrease for slower.
         * - pathSpeed (0.8): Controls auto-pathfinding speed; adjust between 0.1-1.0 for desired pace (current 0.8 matches maxSpeed).
         * - rotationLerpSpeed (0.1): Controls camera rotation speed during pathfinding; 0.05-0.5 range for smooth adjustments.
         * - wallThickness (0.01): Minimum visible thickness; avoid <0.01 to prevent rendering issues.
         * - safeDistance (wallThickness + 0.25): Collision buffer; tweak 0.25 for larger/smaller wall boundaries.
         * - To debug pathfinding: Log 'path' variable or toggle path markers with 'P'.
         *
         * TODO - Ideas for Future Changes:
         * - Implement a minimap showing player position and maze outline
         * - Add collectible items that increase score when picked up
         * - Add sound effects for movement, collisions, and completion
         * - Implement a leaderboard system with local storage for high scores
         * - Add dynamic obstacles that move within the maze
         */

        // Git Commit Command for Version 3.49:
        // git commit -m "Version 3.49: Removed unnecessary opening of start and finish walls in Kruskal’s algorithm, as player starts inside maze" neon-maze3d.html

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        let mazeWidth = 100, mazeHeight = 100;
        const cellSize = 2;
        const wallThickness = 0.01;
        let maze = [], walls = new Map(), floor, ceiling, startMarker, finishMarker;
        let gameActive = false, startTime, score = 0;
        let start = { x: 0, z: 0 }, finish = { x: mazeWidth - 1, z: mazeHeight - 1 };
        let path = null, pathIndex = 0, pathMarkers = [];
        let fogActive = true;
        let fogColor = 0x111111;
        const visibilityRadius = 15;

        let pointLight;
        let wallMaterials = {};

        function generateMaze(difficulty) {
            maze = [];
            for (let x = 0; x < mazeWidth; x++) {
                maze[x] = [];
                for (let z = 0; z < mazeHeight; z++) {
                    maze[x][z] = 1; // 1 = visited (open space)
                }
            }

            let vWalls = Array(mazeWidth + 1).fill().map(() => Array(mazeHeight).fill(true));
            let hWalls = Array(mazeWidth).fill().map(() => Array(mazeHeight + 1).fill(true));

            // Kruskal’s algorithm setup
            const cells = [];
            const edges = [];
            const sets = new Map(); // Disjoint-set data structure

            // Initialize cells and sets
            for (let z = 0; z < mazeHeight; z++) {
                for (let x = 0; x < mazeWidth; x++) {
                    const id = `${x},${z}`;
                    cells.push({ x, z });
                    sets.set(id, [id]); // Each cell starts in its own set
                }
            }

            // Generate all possible edges (walls between cells)
            for (let z = 0; z < mazeHeight; z++) {
                for (let x = 0; x < mazeWidth; x++) {
                    if (x < mazeWidth - 1) {
                        edges.push({ type: 'v', x: x + 1, z, from: `${x},${z}`, to: `${x + 1},${z}` });
                    }
                    if (z < mazeHeight - 1) {
                        edges.push({ type: 'h', x, z: z + 1, from: `${x},${z}`, to: `${x},${z + 1}` });
                    }
                }
            }

            // Shuffle edges with difficulty-based weighting
            const connectionBias = difficulty === 1 ? 0.7 : difficulty === 2 ? 0.5 : 0.3; // Easy: more connections, Hard: fewer
            edges.sort(() => Math.random() - connectionBias);

            // Union-Find functions
            function find(cellId) {
                const set = sets.get(cellId);
                return set[0]; // Representative of the set
            }

            function union(cellId1, cellId2) {
                const set1 = sets.get(cellId1);
                const set2 = sets.get(cellId2);
                const newSet = set1.concat(set2);
                newSet.forEach(id => sets.set(id, newSet));
            }

            // Kruskal’s algorithm: Connect cells by removing walls
            for (const edge of edges) {
                const { type, x, z, from, to } = edge;
                const root1 = find(from);
                const root2 = find(to);

                if (root1 !== root2) {
                    if (type === 'v') {
                        vWalls[x][z] = false;
                    } else if (type === 'h') {
                        hWalls[x][z] = false;
                    }
                    union(from, to);
                }
            }

            // No need to manually open start or finish walls, as player starts inside maze
            maze.vWalls = vWalls;
            maze.hWalls = hWalls;
        }

        function renderMaze() {
            const neonColors = [0xff00ff, 0x00ffff, 0xffff00, 0xff00aa, 0x00ffaa];
            const wallColor = neonColors[Math.floor(Math.random() * neonColors.length)];
            const floorCeilingColor = neonColors[Math.floor(Math.random() * neonColors.length)];
            const boundaryColor = neonColors[(neonColors.indexOf(wallColor) + 1) % neonColors.length];

            wallMaterials.wall = new THREE.MeshPhongMaterial({
                color: wallColor,
                opacity: 1.0,
                transparent: false,
                side: THREE.DoubleSide,
                shininess: 30
            });
            wallMaterials.boundary = new THREE.MeshPhongMaterial({
                color: boundaryColor,
                opacity: 1.0,
                transparent: false,
                side: THREE.DoubleSide,
                shininess: 30
            });
            wallMaterials.floorCeiling = new THREE.MeshPhongMaterial({
                color: floorCeilingColor,
                opacity: 1.0,
                transparent: false,
                side: THREE.DoubleSide,
                shininess: 10
            });

            walls.clear();

            const floorGeometry = new THREE.BoxGeometry(mazeWidth * cellSize, wallThickness, mazeHeight * cellSize);
            floor = new THREE.Mesh(floorGeometry, wallMaterials.floorCeiling);
            floor.position.set(0, -cellSize / 2 + wallThickness / 2, 0);
            scene.add(floor);

            const ceilingGeometry = new THREE.BoxGeometry(mazeWidth * cellSize, wallThickness, mazeHeight * cellSize);
            ceiling = new THREE.Mesh(ceilingGeometry, wallMaterials.floorCeiling);
            ceiling.position.set(0, cellSize / 2 - wallThickness / 2, 0);
            scene.add(ceiling);

            const startMarkerGeometry = new THREE.SphereGeometry(0.3);
            const startMarkerMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00, shininess: 50 });
            startMarker = new THREE.Mesh(startMarkerGeometry, startMarkerMaterial);
            const startX = start.x * cellSize - mazeWidth * cellSize / 2 + cellSize / 2;
            const startZ = start.z * cellSize - mazeHeight * cellSize / 2 + cellSize / 2;
            startMarker.position.set(startX, 0, startZ);
            scene.add(startMarker);

            const finishMarkerGeometry = new THREE.SphereGeometry(0.3);
            const finishMarkerMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000, shininess: 50 });
            finishMarker = new THREE.Mesh(finishMarkerGeometry, finishMarkerMaterial);
            const finishX = finish.x * cellSize - mazeWidth * cellSize / 2 + cellSize / 2;
            const finishZ = finish.z * cellSize - mazeHeight * cellSize / 2 + cellSize / 2;
            finishMarker.position.set(finishX, 0, finishZ);
            scene.add(finishMarker);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            pointLight = new THREE.PointLight(0xffffff, 0.8, 50);
            pointLight.position.set(startX, 2, startZ);
            scene.add(pointLight);

            scene.fog = null;
            updateFog(fogColor);

            camera.position.set(startX, 0.1, startZ);
            gameActive = true;
        }

        function updateVisibleObjects() {
            const playerX = Math.floor((camera.position.x + mazeWidth * cellSize / 2) / cellSize);
            const playerZ = Math.floor((camera.position.z + mazeHeight * cellSize / 2) / cellSize);

            const minX = Math.max(0, playerX - visibilityRadius);
            const maxX = Math.min(mazeWidth, playerX + visibilityRadius);
            const minZ = Math.max(0, playerZ - visibilityRadius);
            const maxZ = Math.min(mazeHeight, playerZ + visibilityRadius);

            const newWalls = new Set();

            for (let x = minX; x <= maxX; x++) {
                for (let z = minZ; z < maxZ; z++) {
                    if (maze.vWalls[x][z]) {
                        let startZ = z;
                        let length = 0;
                        while (startZ + length < mazeHeight && maze.vWalls[x][startZ + length] && startZ + length < maxZ) {
                            length++;
                        }
                        const key = `v_${x}_${startZ}_${length}`;
                        newWalls.add(key);
                        if (!walls.has(key)) {
                            const isBoundary = (x === 0 || x === mazeWidth);
                            const geometry = new THREE.BoxGeometry(wallThickness, cellSize, cellSize * length);
                            const material = isBoundary ? wallMaterials.boundary : wallMaterials.wall;
                            const wall = new THREE.Mesh(geometry, material);
                            const posX = x * cellSize - mazeWidth * cellSize / 2;
                            const posZ = (startZ + (length - 1) / 2) * cellSize - mazeHeight * cellSize / 2 + cellSize / 2;
                            wall.position.set(posX, 0, posZ);
                            scene.add(wall);
                            walls.set(key, { mesh: wall, x: x, z: startZ, length: length, isVertical: true });
                        }
                        z += length - 1;
                    }
                }
            }

            for (let z = minZ; z <= maxZ; z++) {
                for (let x = minX; x < maxX; x++) {
                    if (maze.hWalls[x][z]) {
                        let startX = x;
                        let length = 0;
                        while (startX + length < mazeWidth && maze.hWalls[startX + length][z] && startX + length < maxX) {
                            length++;
                        }
                        const key = `h_${startX}_${z}_${length}`;
                        newWalls.add(key);
                        if (!walls.has(key)) {
                            const isBoundary = (z === 0 || z === mazeHeight);
                            const geometry = new THREE.BoxGeometry(cellSize * length, cellSize, wallThickness);
                            const material = isBoundary ? wallMaterials.boundary : wallMaterials.wall;
                            const wall = new THREE.Mesh(geometry, material);
                            const posX = (startX + (length - 1) / 2) * cellSize - mazeWidth * cellSize / 2 + cellSize / 2;
                            const posZ = z * cellSize - mazeHeight * cellSize / 2;
                            wall.position.set(posX, 0, posZ);
                            scene.add(wall);
                            walls.set(key, { mesh: wall, x: startX, z: z, length: length, isVertical: false });
                        }
                        x += length - 1;
                    }
                }
            }

            for (let [key, wall] of walls) {
                if (!newWalls.has(key)) {
                    scene.remove(wall.mesh);
                    walls.delete(key);
                }
            }
        }

        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        const maxSpeed = 0.8,
              acceleration = 0.1,
              friction = 0.15,
              wallFriction = 0,
              rotationSpeed = 0.002,
              pathSpeed = 0.8,
              rotationLerpSpeed = 0.1;
        let velocity = new THREE.Vector3(0, 0, 0);
        const raycaster = new THREE.Raycaster();

        camera.rotation.y = Math.PI / 2;

        document.addEventListener('mousemove', (e) => {
            if (gameActive && !path) camera.rotation.y -= e.movementX * rotationSpeed;
        });
        document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock;
        document.addEventListener('click', () => {
            if (gameActive && !path) document.body.requestPointerLock();
        });

        let touchStartX = 0, touchStartY = 0;
        let touchActive = false, touchMoveActive = false, touchLookActive = false;
        let lastTouchX = 0, lastTouchY = 0;
        let touchMoveZone, touchLookZone;

        function setupTouchZones() {
            const screenWidth = window.innerWidth;
            touchMoveZone = screenWidth * 0.5;
            touchLookZone = screenWidth * 0.5;
        }

        setupTouchZones();
        window.addEventListener('resize', setupTouchZones);

        document.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1 && gameActive && !path) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                touchActive = true;
                lastTouchX = touchStartX;
                lastTouchY = touchStartY;

                touchMoveActive = touchStartX < touchMoveZone;
                touchLookActive = touchStartX >= touchLookZone;
            }
        });

        document.addEventListener('touchmove', (e) => {
            if (touchActive && e.touches.length === 1 && gameActive && !path) {
                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY;
                const deltaX = touchX - lastTouchX;
                const deltaY = touchY - lastTouchY;

                if (touchMoveActive) {
                    if (Math.abs(deltaY) > Math.abs(deltaX) * 1.5) {
                        moveForward = deltaY < 0;
                        moveBackward = deltaY > 0;
                        moveLeft = false;
                        moveRight = false;
                    } else if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        moveLeft = deltaX < 0;
                        moveRight = deltaX > 0;
                        moveForward = false;
                        moveBackward = false;
                    }
                }

                if (touchLookActive) {
                    const lookDeltaX = deltaX * 0.001;
                    const lookDeltaY = deltaY * 0.0005;
                    camera.rotation.y -= lookDeltaX;
                    camera.rotation.x = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, camera.rotation.x - lookDeltaY));
                }

                lastTouchX = touchX;
                lastTouchY = touchY;
            }
        });

        document.addEventListener('touchend', () => {
            if (gameActive && !path) {
                touchActive = false;
                touchMoveActive = false;
                touchLookActive = false;
                moveForward = moveBackward = moveLeft = moveRight = false;
            }
        });

        document.addEventListener('keydown', (e) => {
            if (gameActive) {
                switch (e.key.toLowerCase()) {
                    case 'w': if (!path) moveForward = true; break;
                    case 's': if (!path) moveBackward = true; break;
                    case 'a': if (!path) moveLeft = true; break;
                    case 'd': if (!path) moveRight = true; break;
                    case 't':
                        if (path) {
                            path = null;
                            velocity.set(0, 0, 0);
                            renderPathMarkers();
                        } else {
                            const startX = Math.floor((camera.position.x + mazeWidth * cellSize / 2) / cellSize);
                            const startZ = Math.floor((camera.position.z + mazeHeight * cellSize / 2) / cellSize);
                            path = aStarPathfinding({ x: startX, z: startZ }, finish);
                            pathIndex = 0;
                            moveForward = moveBackward = moveLeft = moveRight = false;
                            velocity.set(0, 0, 0);
                            renderPathMarkers();
                        }
                        break;
                    case 'p':
                        document.body.classList.toggle('debug-path');
                        renderPathMarkers();
                        break;
                    case 'f':
                        fogActive = !fogActive;
                        updateFog(fogColor);
                        break;
                }
            } else if (e.key === ' ' && achievementElement.style.display === 'block') {
                restartGame();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (gameActive && !path) {
                switch (e.key.toLowerCase()) {
                    case 'w': moveForward = false; break;
                    case 's': moveBackward = false; break;
                    case 'a': moveLeft = false; break;
                    case 'd': moveRight = false; break;
                }
            }
        });

        const uiElement = document.getElementById('ui');
        const achievementElement = document.getElementById('achievementElement');
        const restartButton = document.getElementById('restartButton');
        const menu = document.getElementById('menu');
        const easyButton = document.getElementById('easyButton');
        const mediumButton = document.getElementById('mediumButton');
        const hardButton = document.getElementById('hardButton');

        function setupMenu() {
            easyButton.addEventListener('click', () => startGame(1));    // Easy: more connections
            mediumButton.addEventListener('click', () => startGame(2));  // Medium: balanced
            hardButton.addEventListener('click', () => startGame(3));    // Hard: fewer connections

            [easyButton, mediumButton, hardButton].forEach(button => {
                button.addEventListener('touchstart', (e) => { e.preventDefault(); button.click(); });
            });
        }

        function showMenu() {
            menu.style.display = 'flex';
            gameActive = false;
        }

        function hideMenu() {
            menu.style.display = 'none';
        }

        [achievementElement, restartButton].forEach(element => {
            element.addEventListener('touchstart', (e) => { e.preventDefault(); handleTouchEvent(element); });
            element.addEventListener('click', (e) => { e.preventDefault(); handleTouchEvent(element); });
        });

        function handleTouchEvent(element) {
            if (element === achievementElement || element === restartButton) {
                if (!gameActive) restartGame();
            }
        }

        function startGame(difficulty) {
            console.log(`Starting game with difficulty: ${difficulty}...`);
            hideMenu();
            gameActive = true;
            startTime = performance.now();
            score = 0;
            path = null;
            velocity.set(0, 0, 0);
            moveForward = moveBackward = moveLeft = moveRight = false;
            updateUI();
            generateMaze(difficulty);
            renderMaze();
            animate();
        }

        function showAchievement() {
            achievementElement.style.display = 'block';
            restartButton.style.display = 'block';
            gameActive = false;
            path = null;
            const timeTaken = Math.floor((performance.now() - startTime) / 1000);
            score = Math.max(0, 1000 - timeTaken * 10);
            updateUI();
        }

        function restartGame() {
            scene.clear();
            walls.clear();
            maze = [];
            start = { x: 0, z: 0 };
            finish = { x: mazeWidth - 1, z: mazeHeight - 1 };
            gameActive = true;
            startTime = performance.now();
            path = null;
            velocity.set(0, 0, 0);
            moveForward = moveBackward = moveLeft = moveRight = false;
            pathMarkers.forEach(marker => scene.remove(marker));
            pathMarkers = [];
            showMenu(); // Show menu instead of restarting directly
            achievementElement.style.display = 'none';
            restartButton.style.display = 'none';
        }

        function updateFog(color) {
            if (fogActive) {
                scene.fog = new THREE.Fog(color, 1, 5);
            } else {
                scene.fog = null;
            }
        }

        function updateUI() {
            if (gameActive) {
                const timeElapsed = Math.floor((performance.now() - startTime) / 1000);
                uiElement.textContent = `Score: ${score} | Time: ${timeElapsed}s`;
            }
        }

        function renderPathMarkers() {
            pathMarkers.forEach(marker => scene.remove(marker));
            pathMarkers = [];
            if (path && document.body.classList.contains('debug-path')) {
                path.forEach(node => {
                    const marker = new THREE.Mesh(
                        new THREE.SphereGeometry(0.05),
                        new THREE.MeshBasicMaterial({ color: 0x00ffff })
                    );
                    marker.position.set(
                        node.x * cellSize - mazeWidth * cellSize / 2 + cellSize / 2,
                        0,
                        node.z * cellSize - mazeHeight * cellSize / 2 + cellSize / 2
                    );
                    scene.add(marker);
                    pathMarkers.push(marker);
                });
            }
        }

        function aStarPathfinding(startPos, endPos) {
            const openSet = [startPos];
            const cameFrom = new Map();
            const gScore = new Map();
            const fScore = new Map();

            gScore.set(`${startPos.x},${startPos.z}`, 0);
            fScore.set(`${startPos.x},${startPos.z}`, heuristic(startPos, endPos));

            while (openSet.length > 0) {
                openSet.sort((a, b) => fScore.get(`${a.x},${a.z}`) - fScore.get(`${b.x},${b.z}`));
                const current = openSet.shift();

                if (current.x === endPos.x && current.z === endPos.z) {
                    return reconstructPath(cameFrom, current);
                }

                const neighbors = getNeighbors(current);
                for (const neighbor of neighbors) {
                    const tentativeGScore = gScore.get(`${current.x},${current.z}`) + 1;
                    const neighborKey = `${neighbor.x},${neighbor.z}`;

                    if (!gScore.has(neighborKey) || tentativeGScore < gScore.get(neighborKey)) {
                        cameFrom.set(neighborKey, current);
                        gScore.set(neighborKey, tentativeGScore);
                        fScore.set(neighborKey, tentativeGScore + heuristic(neighbor, endPos));
                        if (!openSet.some(n => n.x === neighbor.x && n.z === neighbor.z)) {
                            openSet.push(neighbor);
                        }
                    }
                }
            }
            return null;
        }

        function heuristic(a, b) {
            return Math.abs(a.x - b.x) + Math.abs(a.z - b.z);
        }

        function getNeighbors(pos) {
            const neighbors = [];
            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
            for (const [dx, dz] of directions) {
                const nx = pos.x + dx;
                const nz = pos.z + dz;
                if (nx >= 0 && nx < mazeWidth && nz >= 0 && nz < mazeHeight) {
                    if (dx === 1 && !maze.vWalls[pos.x + 1][pos.z]) neighbors.push({ x: nx, z: nz });
                    else if (dx === -1 && !maze.vWalls[pos.x][pos.z]) neighbors.push({ x: nx, z: nz });
                    else if (dz === 1 && !maze.hWalls[pos.x][pos.z + 1]) neighbors.push({ x: nx, z: nz });
                    else if (dz === -1 && !maze.hWalls[pos.x][pos.z]) neighbors.push({ x: nx, z: nz });
                }
            }
            return neighbors;
        }

        function reconstructPath(cameFrom, current) {
            const path = [current];
            while (cameFrom.has(`${current.x},${current.z}`)) {
                current = cameFrom.get(`${current.x},${current.z}`);
                path.unshift(current);
            }
            return path;
        }

        function animate() {
            if (!gameActive) return;

            requestAnimationFrame(animate);

            updateVisibleObjects();
            const wallMeshes = Array.from(walls.values()).map(w => w.mesh);

            const startDist = camera.position.distanceTo(startMarker.position);
            startMarker.visible = startDist <= visibilityRadius * cellSize;
            const finishDist = camera.position.distanceTo(finishMarker.position);
            finishMarker.visible = finishDist <= visibilityRadius * cellSize;

            const startX = camera.position.x;
            const startZ = camera.position.z;
            pointLight.position.set(startX, 2, startZ);

            if (path && pathIndex < path.length) {
                const targetGrid = path[pathIndex];
                const targetX = targetGrid.x * cellSize - mazeWidth * cellSize / 2 + cellSize / 2;
                const targetZ = targetGrid.z * cellSize - mazeHeight * cellSize / 2 + cellSize / 2;
                const direction = new THREE.Vector3(targetX - camera.position.x, 0, targetZ - camera.position.z).normalize();

                const targetQuaternion = new THREE.Quaternion().setFromUnitVectors(
                    new THREE.Vector3(0, 0, -1),
                    direction
                );
                camera.quaternion.slerp(targetQuaternion, rotationLerpSpeed);

                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                const moveStep = forward.multiplyScalar(pathSpeed * 0.05);
                let newPosition = camera.position.clone().add(moveStep);

                raycaster.set(camera.position, forward);
                const intersects = raycaster.intersectObjects(wallMeshes);

                if (intersects.length > 0 && intersects[0].distance <= moveStep.length() + wallThickness + 0.25) {
                    const hitPoint = intersects[0].point;
                    const normal = intersects[0].face.normal.clone().applyQuaternion(intersects[0].object.quaternion);
                    const safeDistance = wallThickness + 0.25;
                    newPosition = hitPoint.clone().sub(forward.clone().multiplyScalar(safeDistance));
                }

                camera.position.copy(newPosition);

                if (camera.position.distanceTo(new THREE.Vector3(targetX, camera.position.y, targetZ)) < 0.1) {
                    pathIndex++;
                }
            } else {
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                let moveDirection = new THREE.Vector3();

                if (moveForward) moveDirection.add(forward);
                if (moveBackward) moveDirection.add(forward.clone().negate());
                if (moveLeft) moveDirection.add(right.clone().negate());
                if (moveRight) moveDirection.add(right);

                if (moveDirection.length() > 0) {
                    moveDirection.normalize();
                    velocity.copy(moveDirection.multiplyScalar(maxSpeed));
                } else {
                    velocity.lerp(new THREE.Vector3(0, 0, 0), friction);
                }

                const moveStep = velocity.clone().multiplyScalar(0.1);
                let newPosition = camera.position.clone();

                if (moveStep.length() > 0) {
                    const checkDirections = [
                        forward,
                        forward.clone().negate(),
                        right,
                        right.clone().negate(),
                        forward.clone().add(right).normalize(),
                        forward.clone().sub(right).normalize(),
                        forward.clone().negate().add(right).normalize(),
                        forward.clone().negate().sub(right).normalize()
                    ];

                    let finalMove = moveStep.clone();
                    const safeDistance = wallThickness + 0.25;

                    for (const dir of checkDirections) {
                        raycaster.set(camera.position, dir);
                        const intersects = raycaster.intersectObjects(wallMeshes);
                        if (intersects.length > 0 && intersects[0].distance <= moveStep.length() + safeDistance) {
                            const normal = intersects[0].face.normal.clone().applyQuaternion(intersects[0].object.quaternion);
                            const moveDotNormal = finalMove.dot(normal);
                            if (moveDotNormal < 0) {
                                finalMove.sub(normal.clone().multiplyScalar(moveDotNormal));
                            }
                        }
                    }

                    newPosition.add(finalMove);

                    const sweepDirections = [
                        new THREE.Vector3(1, 0, 0),
                        new THREE.Vector3(-1, 0, 0),
                        new THREE.Vector3(0, 0, 1),
                        new THREE.Vector3(0, 0, -1)
                    ];
                    for (const dir of sweepDirections) {
                        raycaster.set(newPosition, dir);
                        const intersects = raycaster.intersectObjects(wallMeshes);
                        if (intersects.length > 0 && intersects[0].distance < safeDistance) {
                            const normal = intersects[0].face.normal.clone().applyQuaternion(intersects[0].object.quaternion);
                            const correction = normal.clone().multiplyScalar(safeDistance - intersects[0].distance);
                            newPosition.add(correction);
                        }
                    }

                    newPosition.x = Math.max(-mazeWidth * cellSize / 2 + safeDistance, Math.min(mazeWidth * cellSize / 2 - safeDistance, newPosition.x));
                    newPosition.z = Math.max(-mazeHeight * cellSize / 2 + safeDistance, Math.min(mazeHeight * cellSize / 2 - safeDistance, newPosition.z));
                }

                camera.position.copy(newPosition);
                if (velocity.length() < 0.01 && !moveForward && !moveBackward && !moveLeft && !moveRight) {
                    velocity.set(0, 0, 0);
                }
            }

            const distanceToFinish = camera.position.distanceTo(finishMarker.position);
            if (distanceToFinish < 0.5) {
                showAchievement();
            } else if (distanceToFinish < 2) {
                finishMarker.scale.lerp(new THREE.Vector3(1.2, 1.2, 1.2), 0.1);
            } else {
                finishMarker.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
            }

            updateUI();
            renderer.render(scene, camera);
        }

        setupMenu();
        showMenu();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            setupTouchZones();
        });
    </script>
</body>
</html>
